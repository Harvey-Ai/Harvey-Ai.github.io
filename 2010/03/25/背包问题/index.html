<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Hello"><title>背包问题 | Wei's Words</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">背包问题</h1><a id="logo" href="/.">Wei's Words</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-4-4"><div class="content_container"><div class="post"><h1 class="post-title">背包问题</h1><div class="post-meta">2010-03-25<span> | </span><span class="category"><a href="/categories/Algorithm/">Algorithm</a><a href="/categories/Algorithm/Repost/">Repost</a></span></div><div class="post-content"><p>题目<br>有N件物品和一个容量为V的背包。第i件物品的费用是c，价值是w。求解将哪些物品装入背包可 使这些物品的费用总和不超过背包容量，且价值总和最大。<br>基本思路。<br>这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。<br>用子问题定义状态：即f[v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则 其状态转移方程便是：f[v]&#x3D;max{f[v],f[v-c]+w}。<br>这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将它详细 解释一下：“将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只牵扯前i-1件物品的问题。 如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”；如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为 v-c的背包中”，此时能获得的最大价值就是f [v-c]再加上通过放入第i件物品获得的价值w。<br>注意f[v]有意义当且仅当存在一个前i件物品的子集，其费用总和为v。所以按照这个方程递推 完毕后，最终的答案并不一定是f[N] [V]，而是f[N][0..V]的最大值。如果将状态的定义中的“恰”字去掉，在转移方程中就要再加入一项f[v-1]，这样就可以保证f[N][V]就是最后的答案。至于为什么这样就可以，由你自己来体会了。<br>优化空间复杂度。<br>以上方法的时间和空间复杂度均为O(N<em>V)，其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到O(V)。<br>先考虑上面讲的基本思路如何实现，肯定是有一个主循环i&#x3D;1..N，每次算出来二维数组 f[0..V]的所有值。那么，如果只用一个数组f[0..V]，能不能保证第i次循环结束后f[v]中表示的就是我们定义的状态f[v]呢？f[v]是由f[v]和f[v-c]两个子问题递推而来，能否保证在推f[v]时（也即在第i次主循环中推f[v]时）能够得到f[v]和f[v -c]的值呢？事实上，这要求在每次主循环中我们以v&#x3D;V..0的顺序推f[v]，这样才能保证推f[v]时f[v-c]保存的是状态f[v-c]的值。伪代码如下：<br>for i&#x3D;1..N<br>for v&#x3D;V..0<br>f[v]&#x3D;max{f[v],f[v-c]+w};<br>其中的f[v]&#x3D;max{f[v],f[v-c]}一句恰就相当于我们的转移方程f[v]&#x3D;max{f[v],f[v-c]}，因为现在的f[v-c]就相当于原来的f[v-c]。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了f[v]由f[v-c]推知，与本题意不符，但它却是另一个重要的背包问题P02最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。<br>总结<br>01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成01背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。<br>完全背包问题　　题目<br>有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c，价值是w。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。<br>基本思路<br>这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令f[v]表示前i种物品恰放入一个容量为v的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样：f[v]&#x3D;max{f[v-k</em>c]+k<em>w|0&lt;&#x3D;k</em>c&amp; lt;&#x3D; v}。这跟01背包问题一样有O(N<em>V)个状态需要求解，但求解每个状态的时间则不是常数了，求解状态f[v]的时间是O(v&#x2F;c)，总的复杂度是超过 O(VN)的。<br>将01背包问题的基本思路加以改进，得到了这样一个清晰的方法。这说明01背包问题的方程的确是很重要，可以推及其它类型的背包问题。但我们还是试图改进这个复杂度。<br>一个简单有效的优化<br>完全背包问题有一个很简单有效的优化，是这样的：若两件物品i、j满足c&lt;&#x3D;c[j]且 w&gt;&#x3D;w[j]，则将物品j去掉，不用考虑。这个优化的正确性显然：任何情况下都可将价值小费用高得j换成物美价廉的i，得到至少不会更差的方案。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。<br>转化为01背包问题求解<br>既然01背包问题是最基本的背包问题，那么我们可以考虑把完全背包问题转化为01背包问题来解。最简单的想法是，考虑到第i种物品最多选V&#x2F;c 件，于是可以把第i种物品转化为V&#x2F;c件费用及价值均不变的物品，然后求解这个01背包问题。这样完全没有改进基本思路的时间复杂度，但这毕竟给了我们将完全背包问题转化为01背包问题的思路：将一种物品拆成多件物品。<br>更高效的转化方法是：把第i种物品拆成费用为c</em>2^k、价值为w<em>2^k的若干件物品，其中 k满足c</em>2^k&lt;V。这是二进制的思想，因为不管最优策略选几件第i种物品，总可以表示成若干个2^k件物品的和。这样把每种物品拆成 O(log(V&#x2F;c))件物品，是一个很大的改进。但我们有更优的O(VN)的算法。* O(VN)的算法 这个算法使用一维数组，先看伪代码：<br>&lt;pre class”example”&gt; for i&#x3D;1..N for v&#x3D;0..V f[v]&#x3D;max{f[v],f[v-c]+w};<br>你会发现，这个伪代码与P01的伪代码只有v的循环次序不同而已。为什么这样一改就可行呢？首 先想想为什么P01中要按照v&#x3D;V..0的逆序来循环。这是因为要保证第i次循环中的状态f[v]是由状态f[v-c]递推而来。换句话说，这正是为了保 证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果f[v-c]。而现在完全背包的特点恰是每种 物品可选无限件，所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果f[v-c]，所以就可以并且必须采用v&#x3D; 0..V的顺序循环。这就是这个简单的程序为何成立的道理。<br>这个算法也可以以另外的思路得出。例如，基本思路中的状态转移方程可以等价地变形成这种形式：f[v]&#x3D;max{f[v],f[v-c]+w}，将这个方程用一维数组实现，便得到了上面的伪代码。<br>总结<br>完全背包问题也是一个相当基础的背包问题，它有两个状态转移方程，分别在“基本思路”以及“O(VN)的算法“的小节中给出。希望你能够对这两个状态转移方程都仔细地体会，不仅记住，也要弄明白它们是怎么得出来的，最好能够自己想一种得到这些方程的方法。事实上，对每一道动态规划题目都思考其方程的意义以及如何得来，是加深对动态规划的理解、提高动态规划功力的好方法。<br>多重背包问题　　题目 　　有N种物品和一个容量为V的背包。第i种物品最多有n件可用，每件费用是c，价值是w。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。<br>基本算法<br>这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第i 种物品有n+1种策略：取0件，取1件……取 n件。令f[v]表示前i种物品恰放入一个容量为v的背包的最大权值，则：f[v]&#x3D;max{f[v-k<em>c]+ k</em>w|0&lt;&#x3D;k&lt;&#x3D;n}。复杂度是O(V<em>∑n)。<br>转化为01背包问题<br>另一种好想好写的基本方法是转化为01背包求解：把第i种物品换成n件01背包中的物品，则得 到了物品数为∑n的01背包问题，直接求解，复杂度仍然是O(V</em>∑n)。<br>但是我们期望将它转化为01背包问题之后能够像完全背包一样降低复杂度。仍然考虑二进制的思想，我们考虑把第i种物品换成若干件物品，使得原问题中第i种物品可取的每种策略——取0..n件——均能等价于取若干件代换以后的物品。另外，取超过n件的策略必不能出现。<br>方法是：将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来 的费用和价值乘以这个系数。使这些系数分别为 1,2,4,…,2^(k-1),n-2^k+1，且k是满足n-2^k+1&gt;0的最大整数。例如，如果n为13，就将这种物品分成系数分别为 1,2,4,6的四件物品。<br>分成的这几件物品的系数和为n，表明不可能取多于n件的第i种物品。另外这种方法也能保证对于0..n间的每一个整数，均可以用若干个系数的和表示，这个证明可以分0..2^k-1和2^k..n两段来分别讨论得出，并不难，希望你自己思考尝试一 下。<br>这样就将第i种物品分成了O(log n)种物品，将原问题转化为了复杂度为O(V<em>∑log n)的01背包问题，是很大的改进。<br>O(VN)的算法<br>多重背包问题同样有O(VN)的算法。这个算法基于基本算法的状态转移方程，但应用单调队列的方法使每个状态的值可以以均摊O(1)的时间求解。由于用单调队列优化的DP已超出了NOIP的范围，故本文不再展开讲解。<br>小结<br>这里我们看到了将一个算法的复杂度由O(V</em>∑n)改进到O(V*∑log n)的过程，还知道了存在应用超出NOIP范围的知识的O(VN)算法。希望你特别注意“拆分物品”的思想和方法，自己证明一下它的正确性，并用尽量简洁的程序来实现。<br>混合三种背包问题　　问题<br>如果将P01、P02、P03混合起来。也就是说，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。应该怎么求解呢？<br>01背包与完全背包的混合<br>考虑到在P01和P02中最后给出的伪代码只有一处不同，故如果只有两类物品：一类物品只能取 一次，另一类物品可以取无限次，那么只需在对每个物品应用转移方程时，根据物品的类别选用顺序或逆序的循环即可，复杂度是O(VN)。伪代码如下：<br>for i&#x3D;1..N<br>if 第i件物品是01背包<br>for v&#x3D;V..0<br>f[v]&#x3D;max{f[v],f[v-c]+w};<br>else if 第i件物品是完全背包<br>for v&#x3D;0..V<br>f[v]&#x3D;max{f[v],f[v-c]+w};<br>再加上多重背包<br>如果再加上有的物品最多可以取有限次，那么原则上也可以给出O(VN)的解法：遇到多重背包类 型的物品用单调队列解即可。但如果不考虑超过NOIP范围的算法的话，用P03中将每个这类物品分成O(log n)个01背包的物品的方法也已经很优了。<br>小结<br>有人说，困难的题目都是由简单的题目叠加而来的。这句话是否公理暂且存之不论，但它在本讲中已经得到了充分的体现。本来01背包、完全背包、多重背包都不是什么难题，但将它们简单地组合起来以后就得到了这样一道一定能吓倒不少人的题目。但只要基础 扎实，领会三种基本背包问题的思想，就可以做到把困难的题目拆分成简单的题目来解决。<br>二维费用的背包问题　　　　问题<br>二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代 价分别为a和b。两种代价可付出的最大值（两种背包容量）分别为V和U。物品的价值为w。<br>算法<br>费用加了一维，只需状态也加一维即可。设f[v]表示前i件物品付出两种代价分别为v和u时可 获得的最大价值。状态转移方程就是：f[v][u]&#x3D;max{f[v][u],f[v-a][u-b]+w}。如前述方法，可以只使用二维的数组：当每件物品只可以取一次时变量v和u采用顺序的循环，当物品有如完 全背包问题时采用逆序的循环。当物品有如多重背包问题时拆分物品。<br>物品总个数的限制<br>有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取M件物品。这事实上相当于 每件物品多了一种“件数”的费用，每个物品的件数费用均为1，可以付出的最大件数费用为M。换句话说，设f[v][m]表示付出费用v、最多选m件时可得到的最大价值，则根据物品的类型（01、完全、多重）用不同的方法循环更新，最后在f[0..V][0..M]范围内寻找答案。<br>另外，如果要求“恰取M件物品”，则在f[0..V][M]范围内寻找答案。<br>小结<br>事实上，当发现由熟悉的动态规划题目变形得来的题目时，在原来的状态中加一纬以满足新的限制是 一种比较通用的方法。希望你能从本讲中初步体会到这种方法。<br>分组的背包问题　　　　问题<br>有N件物品和一个容量为V的背包。第i件物品的费用是c，价值是w。这些物品被划分为若干组， 每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。<br>算法<br>这个问题变成了每组物品有若干种策略：是选择本组的某一件，还是一件都不选。也就是说设 f[k][v]表示前k组物品花费费用v能取得的最大权值，则有f[k][v]&#x3D;max{f[k-1][v],f[k-1][v-c]+w|物品i属于第 k组}。<br>使用一维数组的伪代码如下：<br>for 所有的组k<br>for 所有的i属于组k<br>for v&#x3D;V..0<br>f[v]&#x3D;max{f[v],f[v-c]+w}<br>另外，显然可以对每组中的物品应用P02中“一个简单有效的优化”。<br>小结<br>分组的背包问题将彼此互斥的若干物品称为一个组，这建立了一个很好的模型。不少背包问题的变形 都可以转化为分组的背包问题（例如P07）。</p>
<p>PS: 在使用背包容量和物品容量时，可以让背包容量和物品容量除以他们的最大公约数，可以做到一些系数上的优化。</p>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%83%8C%E5%8C%85/" rel="tag">背包</a></li></ul></div><div class="post-nav"><a class="pre" href="/2010/03/31/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%B0%8F%E7%BB%93/">并查集小结</a><a class="next" href="/2010/03/10/%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F/">第一个Java程序</a></div></div></div></div><div class="pure-u-1 pure-u-md-4-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">Wei's Words.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>